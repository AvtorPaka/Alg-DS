## A1. Анализ линейного пробирования

**Демченко Георгий Павлович , БПИ-235**

[Условия](https://github.com/AvtorPaka/Alg-DS/blob/master/src/SET_5/AnalysisTasks/spec/spec_1.pdf)

$M$ - **размер хэш-таблицы**

### Insert

```cpp
void Insert(key) {
    size_t ind = hash(key) % M;

    while (table[ind] != null) {
        if (table[ind] == key) {
            return;
        }
        ind = (ind + 1) % M;
    }

    table[ind] = key;
}
```

### Delete

```cpp
void Delete(key) {
    size_t ind = hash(key) % M;

    while (table[ind] != null) {
        if (table[ind] == key) {
            table[ind] = ERASED;
            return;
        }

        ind = (ind + 1) % M;
    }
}
```

### Search

```cpp
bool Search(key) {
    size_t ind = hash(key) % M;

    while (table[ind] != null) {
        if (table[ind] == key) {
            return true;
        }
        ind = (ind + 1) % M;
    }

    return false;
}
```

## 1. Проблема долгого выполнения последовательностей операций

**Проблемы :**

- Игнорирование значения ERASED при вставке нового элемента в таблицу

- Отсутствие смещения элементов в бакетах "справа-налево" при удалении элемента из таблицы

**Анализ :**

При продолжительной вставке элементов в таблицу образуются первичные кластеры (напрямую влияющие на оценку сложности основных операцией с таблицей), которые в силу реализации остануться до момента перехеширования, даже после удаления элемента из таблицы, и, более того, будут только увеличиваться в размерах.

**Пример :**

1. Вставка элементов в таблицу

=> Образование кластеров достаточной длинны (в том числе с смещенными-пробированными элементами из-за колизий)

2. Удаление элементов из хеш-таблицы, замена значений удаленных элементов в кластерах на ERASED

=> Размер кластеров не изменился, так как отсутвует смещение элементов при удалении

3. Вставка элементов в таблицу

=> Так как размер кластеров не изменился и при вставке элементов мы не учитываем статус ERASED элемента, то в случае необходимости смещения-пробирования элемента мы пройдем весь кластер из существующих и псевдо-удаленных элементов, пока не дойдем до конца кластера (NULL), куда и будет вставлен элемент. Таким образом вставка элементов, требующих пробирование, всегда будет происходить в конец кластера, увеличивая его размер.

4. Поиск (удаление) элементов в таблице

=> Если необходимо найти смещенный элемент для удаления или поиска (который находится не на своём индексе в таблице), то нам прийдется пройти большую часть кластера , так как новые элементы всегда вставляются в конец кластера, вне зависимости от ERASED элементов.

=> **В таблице не реализовано уменьшение размеров кластеров (физическое удаление элементов), операции удаления и вставки ничего не меняют, все операции деградируют по временными затратам по мере добавления элементов, в виду постоянного роста размеров класетров.**

**Состояние хеш-таблицы**: Вечные (до рехеширования), увеличивающиеся в размерах первичные кластеры. Бесконечно-увеличивающаяся в размерах таблица без возможности физического удаления элемента.

**Конкретный пример :**

**Обоначим NULL за $\mathit{N}$, ERASED за $\mathit{E}$, значение елемента в таблице за $\mathit{T}_{i}$**

1. Изначально имеем пустую таблицу

$\left[ \mathit{N}, \cdots ,\mathit{N}\right]$

2. Вставим элементы в таблицу, рассмотрим один из образованных кластеров (предположим, что такой имеется)

$\left[ \cdots \mathit{N}, \mathit{T}_{1}, \mathit{T}_{2}, \cdots \mathit{T}_{m - 1}, \mathit{T}_{m},\mathit{N} \cdots \right]$

3. Удалим элементы из таблицы, пусть, для наглядности, удалятся все елементы кластера, кроме краевых

$\left[ \cdots \mathit{N}, \mathit{T}_{1}, \mathit{E}, \cdots \mathit{E}, \mathit{T}_{m},\mathit{N} \cdots \right]$

4. Вставим элемент $\mathit{T}_{m + 1}$, хэш которого совпадает с позицией элемента $\mathit{T}_{1}$

=> Необходимо смещение, $\mathit{E}$ элементы игнорируются, в поисках места проходим весь кластер длинны $m$ и вставляем в позицию после $\mathit{T}_{m}$ (конец кластера)

$\left[ \cdots \mathit{N}, \mathit{T}_{1}, \mathit{E}, \cdots \mathit{E}, \mathit{T}_{m}, \mathit{T}_{m + 1},\mathit{N} \cdots \right]$

=> Выполнено (в худшем случае) $m$ лишних операций поиска места (пройден весь кластер)

5. Последующий поиск и удаление елемента $\mathit{T}_{m+1}$ также займет $m$ лишних операций, так как снова прийдется проходить по всему "пустому" кластеру

=> Таблица и кластеры будут и дальше расти при вставке, не освобождая место $\mathit{E}$ элементов, приводя к деградации операций.

## 2. Исправление операций

**Варианты исправления:**

- **Корректный учет ERASED элементов в алгоритме вставки.** Линейно ищем место во внутреннем массиве покуда не встретится NULL или ERASED. Получаем переиспользование места в кластерах.

- **Смещение элементов "справа-налево" в алгоритме удаления элемента.** После удаления элемента в цикле проходимся по следующим элементам в кластере для заполнения образующихся "пустот" при перекладывании подходящих элементов "справа-налево". Получаем уменьшение размеров кластеров путем их ссужения/разбиения.


Исправление путем смещения элементов при удалени более предпочтительно по сравнению с учетом ERASED элементов, так как при таком подходе поиск и удаление элементов в разрывах кластеров E элементами также потребует полного (большего, в виду существования ERASED элементов) прохода.